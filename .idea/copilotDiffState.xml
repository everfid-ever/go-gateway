<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/reverse_proxy/load_balance/circuit_breaker.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/reverse_proxy/load_balance/circuit_breaker.go" />
              <option name="updatedContent" value="package load_balance&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#9;&quot;sync&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;// CircuitState 熔断器状态&#10;type CircuitState int&#10;&#10;const (&#10;&#9;StateClosed   CircuitState = iota // 关闭状态（正常）&#10;&#9;StateOpen                          // 打开状态（熔断）&#10;&#9;StateHalfOpen                      // 半开状态（尝试恢复）&#10;)&#10;&#10;// CircuitBreaker 熔断器&#10;type CircuitBreaker struct {&#10;&#9;maxFailures     int           // 最大失败次数&#10;&#9;resetTimeout    time.Duration // 重置超时时间&#10;&#9;halfOpenMaxReqs int           // 半开状态最大尝试次数&#10;&#9;&#10;&#9;mu              sync.RWMutex&#10;&#9;state           CircuitState&#10;&#9;failures        int&#10;&#9;lastFailureTime time.Time&#10;&#9;halfOpenReqs    int&#10;}&#10;&#10;// CircuitBreakerConfig 熔断器配置&#10;type CircuitBreakerConfig struct {&#10;&#9;MaxFailures     int           // 触发熔断的失败次数阈值&#10;&#9;ResetTimeout    time.Duration // 从Open到HalfOpen的超时时间&#10;&#9;HalfOpenMaxReqs int           // 半开状态下最大尝试请求数&#10;}&#10;&#10;// NewCircuitBreaker 创建熔断器&#10;func NewCircuitBreaker(config CircuitBreakerConfig) *CircuitBreaker {&#10;&#9;if config.MaxFailures &lt;= 0 {&#10;&#9;&#9;config.MaxFailures = 5&#10;&#9;}&#10;&#9;if config.ResetTimeout &lt;= 0 {&#10;&#9;&#9;config.ResetTimeout = 60 * time.Second&#10;&#9;}&#10;&#9;if config.HalfOpenMaxReqs &lt;= 0 {&#10;&#9;&#9;config.HalfOpenMaxReqs = 1&#10;&#9;}&#10;&#10;&#9;return &amp;CircuitBreaker{&#10;&#9;&#9;maxFailures:     config.MaxFailures,&#10;&#9;&#9;resetTimeout:    config.ResetTimeout,&#10;&#9;&#9;halfOpenMaxReqs: config.HalfOpenMaxReqs,&#10;&#9;&#9;state:           StateClosed,&#10;&#9;}&#10;}&#10;&#10;// Call 执行调用（包装业务逻辑）&#10;func (cb *CircuitBreaker) Call(fn func() error) error {&#10;&#9;if !cb.AllowRequest() {&#10;&#9;&#9;return errors.New(&quot;circuit breaker is open&quot;)&#10;&#9;}&#10;&#10;&#9;err := fn()&#10;&#9;&#10;&#9;if err != nil {&#10;&#9;&#9;cb.RecordFailure()&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;cb.RecordSuccess()&#10;&#9;return nil&#10;}&#10;&#10;// AllowRequest 判断是否允许请求通过&#10;func (cb *CircuitBreaker) AllowRequest() bool {&#10;&#9;cb.mu.Lock()&#10;&#9;defer cb.mu.Unlock()&#10;&#10;&#9;switch cb.state {&#10;&#9;case StateClosed:&#10;&#9;&#9;return true&#10;&#9;case StateOpen:&#10;&#9;&#9;// 检查是否到达重置时间&#10;&#9;&#9;if time.Since(cb.lastFailureTime) &gt; cb.resetTimeout {&#10;&#9;&#9;&#9;cb.state = StateHalfOpen&#10;&#9;&#9;&#9;cb.halfOpenReqs = 0&#10;&#9;&#9;&#9;return true&#10;&#9;&#9;}&#10;&#9;&#9;return false&#10;&#9;case StateHalfOpen:&#10;&#9;&#9;// 半开状态限制请求数量&#10;&#9;&#9;return cb.halfOpenReqs &lt; cb.halfOpenMaxReqs&#10;&#9;default:&#10;&#9;&#9;return false&#10;&#9;}&#10;}&#10;&#10;// RecordSuccess 记录成功&#10;func (cb *CircuitBreaker) RecordSuccess() {&#10;&#9;cb.mu.Lock()&#10;&#9;defer cb.mu.Unlock()&#10;&#10;&#9;if cb.state == StateHalfOpen {&#10;&#9;&#9;cb.halfOpenReqs++&#10;&#9;&#9;// 半开状态下成功，尝试关闭熔断器&#10;&#9;&#9;if cb.halfOpenReqs &gt;= cb.halfOpenMaxReqs {&#10;&#9;&#9;&#9;cb.state = StateClosed&#10;&#9;&#9;&#9;cb.failures = 0&#10;&#9;&#9;}&#10;&#9;} else if cb.state == StateClosed {&#10;&#9;&#9;// 成功时减少失败计数，但不低于0&#10;&#9;&#9;if cb.failures &gt; 0 {&#10;&#9;&#9;&#9;cb.failures--&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;// RecordFailure 记录失败&#10;func (cb *CircuitBreaker) RecordFailure() {&#10;&#9;cb.mu.Lock()&#10;&#9;defer cb.mu.Unlock()&#10;&#10;&#9;cb.failures++&#10;&#9;cb.lastFailureTime = time.Now()&#10;&#10;&#9;if cb.state == StateHalfOpen {&#10;&#9;&#9;// 半开状态失败，重新打开熔断器&#10;&#9;&#9;cb.state = StateOpen&#10;&#9;} else if cb.state == StateClosed &amp;&amp; cb.failures &gt;= cb.maxFailures {&#10;&#9;&#9;// 失败次数达到阈值，打开熔断器&#10;&#9;&#9;cb.state = StateOpen&#10;&#9;}&#10;}&#10;&#10;// GetState 获取当前状态&#10;func (cb *CircuitBreaker) GetState() CircuitState {&#10;&#9;cb.mu.RLock()&#10;&#9;defer cb.mu.RUnlock()&#10;&#9;return cb.state&#10;}&#10;&#10;// GetFailures 获取失败次数&#10;func (cb *CircuitBreaker) GetFailures() int {&#10;&#9;cb.mu.RLock()&#10;&#9;defer cb.mu.RUnlock()&#10;&#9;return cb.failures&#10;}&#10;&#10;// Reset 重置熔断器&#10;func (cb *CircuitBreaker) Reset() {&#10;&#9;cb.mu.Lock()&#10;&#9;defer cb.mu.Unlock()&#10;&#9;cb.state = StateClosed&#10;&#9;cb.failures = 0&#10;&#9;cb.halfOpenReqs = 0&#10;}&#10;&#10;// NodeCircuitBreaker 节点级别的熔断器管理&#10;type NodeCircuitBreaker struct {&#10;&#9;breakers map[string]*CircuitBreaker&#10;&#9;config   CircuitBreakerConfig&#10;&#9;mu       sync.RWMutex&#10;}&#10;&#10;// NewNodeCircuitBreaker 创建节点熔断器管理器&#10;func NewNodeCircuitBreaker(config CircuitBreakerConfig) *NodeCircuitBreaker {&#10;&#9;return &amp;NodeCircuitBreaker{&#10;&#9;&#9;breakers: make(map[string]*CircuitBreaker),&#10;&#9;&#9;config:   config,&#10;&#9;}&#10;}&#10;&#10;// GetBreaker 获取或创建节点的熔断器&#10;func (ncb *NodeCircuitBreaker) GetBreaker(addr string) *CircuitBreaker {&#10;&#9;ncb.mu.RLock()&#10;&#9;breaker, exists := ncb.breakers[addr]&#10;&#9;ncb.mu.RUnlock()&#10;&#10;&#9;if exists {&#10;&#9;&#9;return breaker&#10;&#9;}&#10;&#10;&#9;ncb.mu.Lock()&#10;&#9;defer ncb.mu.Unlock()&#10;&#10;&#9;// 双重检查&#10;&#9;if breaker, exists = ncb.breakers[addr]; exists {&#10;&#9;&#9;return breaker&#10;&#9;}&#10;&#10;&#9;breaker = NewCircuitBreaker(ncb.config)&#10;&#9;ncb.breakers[addr] = breaker&#10;&#9;return breaker&#10;}&#10;&#10;// Call 对特定节点执行调用&#10;func (ncb *NodeCircuitBreaker) Call(addr string, fn func() error) error {&#10;&#9;breaker := ncb.GetBreaker(addr)&#10;&#9;return breaker.Call(fn)&#10;}&#10;&#10;// IsAvailable 检查节点是否可用&#10;func (ncb *NodeCircuitBreaker) IsAvailable(addr string) bool {&#10;&#9;breaker := ncb.GetBreaker(addr)&#10;&#9;return breaker.AllowRequest()&#10;}&#10;&#10;// GetState 获取节点的熔断器状态&#10;func (ncb *NodeCircuitBreaker) GetState(addr string) CircuitState {&#10;&#9;breaker := ncb.GetBreaker(addr)&#10;&#9;return breaker.GetState()&#10;}&#10;&#10;// ResetNode 重置特定节点的熔断器&#10;func (ncb *NodeCircuitBreaker) ResetNode(addr string) {&#10;&#9;ncb.mu.RLock()&#10;&#9;breaker, exists := ncb.breakers[addr]&#10;&#9;ncb.mu.RUnlock()&#10;&#10;&#9;if exists {&#10;&#9;&#9;breaker.Reset()&#10;&#9;}&#10;}&#10;&#10;// GetAllStates 获取所有节点的状态&#10;func (ncb *NodeCircuitBreaker) GetAllStates() map[string]CircuitState {&#10;&#9;ncb.mu.RLock()&#10;&#9;defer ncb.mu.RUnlock()&#10;&#10;&#9;states := make(map[string]CircuitState)&#10;&#9;for addr, breaker := range ncb.breakers {&#10;&#9;&#9;states[addr] = breaker.GetState()&#10;&#9;}&#10;&#9;return states&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/reverse_proxy/load_balance/enhanced_lb.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/reverse_proxy/load_balance/enhanced_lb.go" />
              <option name="updatedContent" value="package load_balance&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;sync&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;// LoadBalanceOptions 负载均衡器选项&#10;type LoadBalanceOptions struct {&#10;&#9;LbType              LbType                  // 负载均衡类型&#10;&#9;Config              LoadBalanceConf         // 配置&#10;&#9;EnableCircuitBreaker bool                   // 是否启用熔断器&#10;&#9;CircuitBreakerConfig CircuitBreakerConfig   // 熔断器配置&#10;&#9;EnableHealthCheck   bool                    // 是否启用健康检查&#10;&#9;HealthChecker       HealthChecker           // 健康检查器&#10;&#9;EnableMetrics       bool                    // 是否启用指标收集&#10;}&#10;&#10;// EnhancedLoadBalance 增强的负载均衡器&#10;type EnhancedLoadBalance struct {&#10;&#9;lb               LoadBalance            // 底层负载均衡器&#10;&#9;circuitBreaker   *NodeCircuitBreaker    // 熔断器&#10;&#9;healthChecker    HealthChecker          // 健康检查器&#10;&#9;enableMetrics    bool                   // 是否启用指标&#10;&#9;mu               sync.RWMutex&#10;}&#10;&#10;// NewEnhancedLoadBalance 创建增强的负载均衡器&#10;func NewEnhancedLoadBalance(opts LoadBalanceOptions) (*EnhancedLoadBalance, error) {&#10;&#9;// 创建底层负载均衡器&#10;&#9;var lb LoadBalance&#10;&#9;if opts.Config != nil {&#10;&#9;&#9;lb = LoadBanlanceFactorWithConf(opts.LbType, opts.Config)&#10;&#9;} else {&#10;&#9;&#9;lb = LoadBanlanceFactory(opts.LbType)&#10;&#9;}&#10;&#10;&#9;elb := &amp;EnhancedLoadBalance{&#10;&#9;&#9;lb:            lb,&#10;&#9;&#9;enableMetrics: opts.EnableMetrics,&#10;&#9;}&#10;&#10;&#9;// 初始化熔断器&#10;&#9;if opts.EnableCircuitBreaker {&#10;&#9;&#9;elb.circuitBreaker = NewNodeCircuitBreaker(opts.CircuitBreakerConfig)&#10;&#9;}&#10;&#10;&#9;// 初始化健康检查器&#10;&#9;if opts.EnableHealthCheck &amp;&amp; opts.HealthChecker != nil {&#10;&#9;&#9;elb.healthChecker = opts.HealthChecker&#10;&#9;&#9;&#10;&#9;&#9;// 为所有节点添加健康检查&#10;&#9;&#9;nodes := lb.GetAllNodes()&#10;&#9;&#9;for _, node := range nodes {&#10;&#9;&#9;&#9;if tcpChecker, ok := opts.HealthChecker.(*TCPHealthChecker); ok {&#10;&#9;&#9;&#9;&#9;tcpChecker.AddAddress(node)&#10;&#9;&#9;&#9;} else if httpChecker, ok := opts.HealthChecker.(*HTTPHealthChecker); ok {&#10;&#9;&#9;&#9;&#9;httpChecker.AddAddress(node)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;&#9;&#10;&#9;&#9;// 启动健康检查&#10;&#9;&#9;elb.healthChecker.Start()&#10;&#9;}&#10;&#10;&#9;return elb, nil&#10;}&#10;&#10;// Get 获取节点（带熔断和健康检查）&#10;func (elb *EnhancedLoadBalance) Get(key string) (string, error) {&#10;&#9;maxRetries := 3&#10;&#9;var lastErr error&#10;&#10;&#9;for i := 0; i &lt; maxRetries; i++ {&#10;&#9;&#9;addr, err := elb.lb.Get(key)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;return &quot;&quot;, err&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 检查熔断器&#10;&#9;&#9;if elb.circuitBreaker != nil &amp;&amp; !elb.circuitBreaker.IsAvailable(addr) {&#10;&#9;&#9;&#9;lastErr = fmt.Errorf(&quot;circuit breaker is open for node: %s&quot;, addr)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 检查健康状态&#10;&#9;&#9;if elb.healthChecker != nil {&#10;&#9;&#9;&#9;metrics := elb.healthChecker.GetMetrics(addr)&#10;&#9;&#9;&#9;if metrics != nil &amp;&amp; metrics.Status == StatusUnhealthy {&#10;&#9;&#9;&#9;&#9;lastErr = fmt.Errorf(&quot;node is unhealthy: %s&quot;, addr)&#10;&#9;&#9;&#9;&#9;continue&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;return addr, nil&#10;&#9;}&#10;&#10;&#9;if lastErr != nil {&#10;&#9;&#9;return &quot;&quot;, lastErr&#10;&#9;}&#10;&#9;return &quot;&quot;, fmt.Errorf(&quot;no available node found&quot;)&#10;}&#10;&#10;// Add 添加节点&#10;func (elb *EnhancedLoadBalance) Add(params ...string) error {&#10;&#9;err := elb.lb.Add(params...)&#10;&#9;if err != nil {&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;// 添加到健康检查&#10;&#9;if elb.healthChecker != nil &amp;&amp; len(params) &gt; 0 {&#10;&#9;&#9;addr := params[0]&#10;&#9;&#9;if tcpChecker, ok := elb.healthChecker.(*TCPHealthChecker); ok {&#10;&#9;&#9;&#9;tcpChecker.AddAddress(addr)&#10;&#9;&#9;} else if httpChecker, ok := elb.healthChecker.(*HTTPHealthChecker); ok {&#10;&#9;&#9;&#9;httpChecker.AddAddress(addr)&#10;&#9;&#9;}&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// RemoveNode 移除节点&#10;func (elb *EnhancedLoadBalance) RemoveNode(addr string) error {&#10;&#9;return elb.lb.RemoveNode(addr)&#10;}&#10;&#10;// GetAllNodes 获取所有节点&#10;func (elb *EnhancedLoadBalance) GetAllNodes() []string {&#10;&#9;return elb.lb.GetAllNodes()&#10;}&#10;&#10;// Update 更新配置&#10;func (elb *EnhancedLoadBalance) Update() {&#10;&#9;elb.lb.Update()&#10;}&#10;&#10;// RecordSuccess 记录成功请求&#10;func (elb *EnhancedLoadBalance) RecordSuccess(addr string, latency time.Duration) {&#10;&#9;// 记录到熔断器&#10;&#9;if elb.circuitBreaker != nil {&#10;&#9;&#9;breaker := elb.circuitBreaker.GetBreaker(addr)&#10;&#9;&#9;breaker.RecordSuccess()&#10;&#9;}&#10;&#10;&#9;// 记录到负载均衡器统计&#10;&#9;if elb.enableMetrics {&#10;&#9;&#9;if stats, ok := elb.lb.(LoadBalanceStats); ok {&#10;&#9;&#9;&#9;stats.RecordRequest(addr, true, latency.Milliseconds())&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;// RecordFailure 记录失败请求&#10;func (elb *EnhancedLoadBalance) RecordFailure(addr string, latency time.Duration) {&#10;&#9;// 记录到熔断器&#10;&#9;if elb.circuitBreaker != nil {&#10;&#9;&#9;breaker := elb.circuitBreaker.GetBreaker(addr)&#10;&#9;&#9;breaker.RecordFailure()&#10;&#9;}&#10;&#10;&#9;// 记录到负载均衡器统计&#10;&#9;if elb.enableMetrics {&#10;&#9;&#9;if stats, ok := elb.lb.(LoadBalanceStats); ok {&#10;&#9;&#9;&#9;stats.RecordRequest(addr, false, latency.Milliseconds())&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;// GetStats 获取统计信息&#10;func (elb *EnhancedLoadBalance) GetStats() map[string]*NodeStats {&#10;&#9;if stats, ok := elb.lb.(LoadBalanceStats); ok {&#10;&#9;&#9;return stats.GetStats()&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;// GetCircuitBreakerStates 获取所有节点的熔断器状态&#10;func (elb *EnhancedLoadBalance) GetCircuitBreakerStates() map[string]CircuitState {&#10;&#9;if elb.circuitBreaker != nil {&#10;&#9;&#9;return elb.circuitBreaker.GetAllStates()&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;// GetHealthMetrics 获取健康检查指标&#10;func (elb *EnhancedLoadBalance) GetHealthMetrics() map[string]*NodeMetrics {&#10;&#9;if elb.healthChecker == nil {&#10;&#9;&#9;return nil&#10;&#9;}&#10;&#10;&#9;nodes := elb.lb.GetAllNodes()&#10;&#9;metrics := make(map[string]*NodeMetrics)&#10;&#9;&#10;&#9;for _, node := range nodes {&#10;&#9;&#9;if m := elb.healthChecker.GetMetrics(node); m != nil {&#10;&#9;&#9;&#9;metrics[node] = m&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;&#10;&#9;return metrics&#10;}&#10;&#10;// Stop 停止负载均衡器&#10;func (elb *EnhancedLoadBalance) Stop() {&#10;&#9;if elb.healthChecker != nil {&#10;&#9;&#9;elb.healthChecker.Stop()&#10;&#9;}&#10;}&#10;&#10;// GetNodeStatus 获取节点完整状态&#10;type NodeStatus struct {&#10;&#9;Addr           string        `json:&quot;addr&quot;`&#10;&#9;IsHealthy      bool          `json:&quot;is_healthy&quot;`&#10;&#9;CircuitState   CircuitState  `json:&quot;circuit_state&quot;`&#10;&#9;Stats          *NodeStats    `json:&quot;stats,omitempty&quot;`&#10;&#9;HealthMetrics  *NodeMetrics  `json:&quot;health_metrics,omitempty&quot;`&#10;}&#10;&#10;// GetAllNodeStatus 获取所有节点的完整状态&#10;func (elb *EnhancedLoadBalance) GetAllNodeStatus() []*NodeStatus {&#10;&#9;nodes := elb.lb.GetAllNodes()&#10;&#9;statuses := make([]*NodeStatus, 0, len(nodes))&#10;&#10;&#9;stats := elb.GetStats()&#10;&#9;cbStates := elb.GetCircuitBreakerStates()&#10;&#9;healthMetrics := elb.GetHealthMetrics()&#10;&#10;&#9;for _, node := range nodes {&#10;&#9;&#9;status := &amp;NodeStatus{&#10;&#9;&#9;&#9;Addr: node,&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 设置统计信息&#10;&#9;&#9;if stats != nil {&#10;&#9;&#9;&#9;if s, ok := stats[node]; ok {&#10;&#9;&#9;&#9;&#9;status.Stats = s&#10;&#9;&#9;&#9;&#9;status.IsHealthy = s.IsHealthy&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 设置熔断器状态&#10;&#9;&#9;if cbStates != nil {&#10;&#9;&#9;&#9;if state, ok := cbStates[node]; ok {&#10;&#9;&#9;&#9;&#9;status.CircuitState = state&#10;&#9;&#9;&#9;&#9;// 如果熔断器打开，节点不健康&#10;&#9;&#9;&#9;&#9;if state == StateOpen {&#10;&#9;&#9;&#9;&#9;&#9;status.IsHealthy = false&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// 设置健康检查指标&#10;&#9;&#9;if healthMetrics != nil {&#10;&#9;&#9;&#9;if m, ok := healthMetrics[node]; ok {&#10;&#9;&#9;&#9;&#9;status.HealthMetrics = m&#10;&#9;&#9;&#9;&#9;// 健康检查失败，节点不健康&#10;&#9;&#9;&#9;&#9;if m.Status == StatusUnhealthy {&#10;&#9;&#9;&#9;&#9;&#9;status.IsHealthy = false&#10;&#9;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#10;&#9;&#9;statuses = append(statuses, status)&#10;&#9;}&#10;&#10;&#9;return statuses&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/reverse_proxy/load_balance/examples.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/reverse_proxy/load_balance/examples.go" />
              <option name="updatedContent" value="package load_balance&#10;&#10;import (&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;// Example_basicUsage 基本用法示例&#10;func Example_basicUsage() {&#10;&#9;// 1. 创建简单的负载均衡器&#10;&#9;lb := LoadBanlanceFactory(LbWeightRoundRobin)&#10;&#9;&#10;&#9;// 2. 添加节点&#10;&#9;_ = lb.Add(&quot;192.168.1.1:8080&quot;, &quot;100&quot;)&#10;&#9;_ = lb.Add(&quot;192.168.1.2:8080&quot;, &quot;50&quot;)&#10;&#9;_ = lb.Add(&quot;192.168.1.3:8080&quot;, &quot;30&quot;)&#10;&#9;&#10;&#9;// 3. 获取节点&#10;&#9;addr, _ := lb.Get(&quot;some-key&quot;)&#10;&#9;fmt.Println(&quot;Selected node:&quot;, addr)&#10;}&#10;&#10;// Example_enhancedLoadBalance 增强负载均衡器示例&#10;func Example_enhancedLoadBalance() {&#10;&#9;// 1. 创建配置&#10;&#9;ipConf := map[string]string{&#10;&#9;&#9;&quot;192.168.1.1:8080&quot;: &quot;100&quot;,&#10;&#9;&#9;&quot;192.168.1.2:8080&quot;: &quot;50&quot;,&#10;&#9;&#9;&quot;192.168.1.3:8080&quot;: &quot;30&quot;,&#10;&#9;}&#10;&#9;&#10;&#9;conf, _ := NewLoadBalanceCheckConf(&quot;http://%s&quot;, ipConf)&#10;&#9;&#10;&#9;// 2. 创建健康检查器&#10;&#9;healthChecker := NewTCPHealthChecker(&#10;&#9;&#9;5*time.Second,  // 超时时间&#10;&#9;&#9;10*time.Second, // 检查间隔&#10;&#9;&#9;3,              // 最大失败次数&#10;&#9;)&#10;&#9;&#10;&#9;// 3. 创建熔断器配置&#10;&#9;cbConfig := CircuitBreakerConfig{&#10;&#9;&#9;MaxFailures:     5,              // 5次失败后熔断&#10;&#9;&#9;ResetTimeout:    60 * time.Second, // 60秒后尝试恢复&#10;&#9;&#9;HalfOpenMaxReqs: 2,              // 半开状态最多2个请求&#10;&#9;}&#10;&#9;&#10;&#9;// 4. 创建增强的负载均衡器&#10;&#9;opts := LoadBalanceOptions{&#10;&#9;&#9;LbType:              LbWeightRoundRobin,&#10;&#9;&#9;Config:              conf,&#10;&#9;&#9;EnableCircuitBreaker: true,&#10;&#9;&#9;CircuitBreakerConfig: cbConfig,&#10;&#9;&#9;EnableHealthCheck:   true,&#10;&#9;&#9;HealthChecker:       healthChecker,&#10;&#9;&#9;EnableMetrics:       true,&#10;&#9;}&#10;&#9;&#10;&#9;elb, _ := NewEnhancedLoadBalance(opts)&#10;&#9;defer elb.Stop()&#10;&#9;&#10;&#9;// 5. 使用负载均衡器&#10;&#9;addr, err := elb.Get(&quot;user-123&quot;)&#10;&#9;if err != nil {&#10;&#9;&#9;fmt.Println(&quot;Error:&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#9;&#10;&#9;// 6. 模拟请求&#10;&#9;start := time.Now()&#10;&#9;// ... 执行实际请求 ...&#10;&#9;latency := time.Since(start)&#10;&#9;&#10;&#9;// 7. 记录结果&#10;&#9;elb.RecordSuccess(addr, latency)&#10;&#9;&#10;&#9;// 8. 获取统计信息&#10;&#9;stats := elb.GetStats()&#10;&#9;for addr, stat := range stats {&#10;&#9;&#9;fmt.Printf(&quot;Node: %s, Requests: %d, Success: %d, Failed: %d, Avg Latency: %dms\n&quot;,&#10;&#9;&#9;&#9;addr, stat.TotalRequests, stat.SuccessRequests, stat.FailedRequests, stat.AvgLatency)&#10;&#9;}&#10;&#9;&#10;&#9;// 9. 获取节点状态&#10;&#9;nodeStatuses := elb.GetAllNodeStatus()&#10;&#9;for _, status := range nodeStatuses {&#10;&#9;&#9;fmt.Printf(&quot;Node: %s, Healthy: %v, Circuit State: %d\n&quot;,&#10;&#9;&#9;&#9;status.Addr, status.IsHealthy, status.CircuitState)&#10;&#9;}&#10;}&#10;&#10;// Example_withCircuitBreaker 熔断器使用示例&#10;func Example_withCircuitBreaker() {&#10;&#9;// 创建熔断器&#10;&#9;config := CircuitBreakerConfig{&#10;&#9;&#9;MaxFailures:     3,&#10;&#9;&#9;ResetTimeout:    30 * time.Second,&#10;&#9;&#9;HalfOpenMaxReqs: 1,&#10;&#9;}&#10;&#9;&#10;&#9;cb := NewCircuitBreaker(config)&#10;&#9;&#10;&#9;// 使用熔断器包装请求&#10;&#9;err := cb.Call(func() error {&#10;&#9;&#9;// 执行实际请求&#10;&#9;&#9;// return someHTTPCall()&#10;&#9;&#9;return nil&#10;&#9;})&#10;&#9;&#10;&#9;if err != nil {&#10;&#9;&#9;fmt.Println(&quot;Request failed:&quot;, err)&#10;&#9;}&#10;&#9;&#10;&#9;// 检查熔断器状态&#10;&#9;state := cb.GetState()&#10;&#9;fmt.Printf(&quot;Circuit breaker state: %d\n&quot;, state)&#10;}&#10;&#10;// Example_dynamicNodeManagement 动态节点管理示例&#10;func Example_dynamicNodeManagement() {&#10;&#9;// 创建配置&#10;&#9;ipConf := map[string]string{&#10;&#9;&#9;&quot;192.168.1.1:8080&quot;: &quot;100&quot;,&#10;&#9;}&#10;&#9;&#10;&#9;conf, _ := NewLoadBalanceCheckConf(&quot;http://%s&quot;, ipConf)&#10;&#9;&#10;&#9;lb := LoadBanlanceFactorWithConf(LbWeightRoundRobin, conf)&#10;&#9;&#10;&#9;// 动态添加节点&#10;&#9;conf.AddNode(&quot;192.168.1.2:8080&quot;, &quot;50&quot;)&#10;&#9;&#10;&#9;// 动态移除节点&#10;&#9;conf.RemoveNode(&quot;192.168.1.1:8080&quot;)&#10;&#9;&#10;&#9;// 获取当前配置版本&#10;&#9;version := conf.GetVersion()&#10;&#9;fmt.Printf(&quot;Config version: %d\n&quot;, version)&#10;&#9;&#10;&#9;// 获取所有节点&#10;&#9;nodes := lb.GetAllNodes()&#10;&#9;fmt.Println(&quot;Current nodes:&quot;, nodes)&#10;}&#10;&#10;// Example_withServiceDiscovery 服务发现示例&#10;func Example_withServiceDiscovery() {&#10;&#9;// 创建静态服务发现&#10;&#9;services := []string{&#10;&#9;&#9;&quot;192.168.1.1:8080&quot;,&#10;&#9;&#9;&quot;192.168.1.2:8080&quot;,&#10;&#9;&#9;&quot;192.168.1.3:8080&quot;,&#10;&#9;}&#10;&#9;&#10;&#9;discovery := NewStaticDiscovery(services)&#10;&#9;&#10;&#9;// 创建权重配置&#10;&#9;weights := map[string]string{&#10;&#9;&#9;&quot;192.168.1.1:8080&quot;: &quot;100&quot;,&#10;&#9;&#9;&quot;192.168.1.2:8080&quot;: &quot;50&quot;,&#10;&#9;&#9;&quot;192.168.1.3:8080&quot;: &quot;30&quot;,&#10;&#9;}&#10;&#9;&#10;&#9;// 创建基于服务发现的配置&#10;&#9;conf, _ := NewLoadBalanceDiscoveryConf(&quot;http://%s&quot;, discovery, weights)&#10;&#9;&#10;&#9;// 创建负载均衡器&#10;&#9;lb := LoadBanlanceFactorWithConf(LbRoundRobin, conf)&#10;&#9;&#10;&#9;// 监听服务变化&#10;&#9;discovery.Watch(func(services []string) {&#10;&#9;&#9;fmt.Println(&quot;Services updated:&quot;, services)&#10;&#9;})&#10;&#9;&#10;&#9;// 使用负载均衡器&#10;&#9;addr, _ := lb.Get(&quot;key&quot;)&#10;&#9;fmt.Println(&quot;Selected node:&quot;, addr)&#10;&#9;&#10;&#9;// 动态更新服务列表&#10;&#9;discovery.UpdateServices([]string{&#10;&#9;&#9;&quot;192.168.1.1:8080&quot;,&#10;&#9;&#9;&quot;192.168.1.4:8080&quot;, // 新节点&#10;&#9;})&#10;}&#10;&#10;// Example_healthChecker HTTP健康检查示例&#10;func Example_healthChecker() {&#10;&#9;// 创建HTTP健康检查器&#10;&#9;healthChecker := NewHTTPHealthChecker(&#10;&#9;&#9;5*time.Second,   // 超时时间&#10;&#9;&#9;10*time.Second,  // 检查间隔&#10;&#9;&#9;3,               // 最大失败次数&#10;&#9;&#9;&quot;/health&quot;,       // 健康检查路径&#10;&#9;&#9;200,             // 期望的状态码&#10;&#9;)&#10;&#9;&#10;&#9;// 添加要检查的地址&#10;&#9;healthChecker.AddAddress(&quot;192.168.1.1:8080&quot;)&#10;&#9;healthChecker.AddAddress(&quot;192.168.1.2:8080&quot;)&#10;&#9;&#10;&#9;// 启动健康检查&#10;&#9;healthChecker.Start()&#10;&#9;defer healthChecker.Stop()&#10;&#9;&#10;&#9;// 等待一些检查完成&#10;&#9;time.Sleep(15 * time.Second)&#10;&#9;&#10;&#9;// 获取健康节点&#10;&#9;healthyNodes := healthChecker.GetHealthyNodes()&#10;&#9;fmt.Println(&quot;Healthy nodes:&quot;, healthyNodes)&#10;&#9;&#10;&#9;// 获取特定节点的指标&#10;&#9;metrics := healthChecker.GetMetrics(&quot;192.168.1.1:8080&quot;)&#10;&#9;if metrics != nil {&#10;&#9;&#9;fmt.Printf(&quot;Node metrics - Total: %d, Success: %d, Failed: %d, Avg Latency: %v, Status: %d\n&quot;,&#10;&#9;&#9;&#9;metrics.TotalRequests, metrics.SuccessRequests, metrics.FailedRequests,&#10;&#9;&#9;&#9;metrics.AvgLatency, metrics.Status)&#10;&#9;}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/reverse_proxy/load_balance/health_checker.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/reverse_proxy/load_balance/health_checker.go" />
              <option name="updatedContent" value="package load_balance&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;net&quot;&#10;&#9;&quot;net/http&quot;&#10;&#9;&quot;sync&quot;&#10;&#9;&quot;time&quot;&#10;)&#10;&#10;// HealthStatus 节点健康状态&#10;type HealthStatus int&#10;&#10;const (&#10;&#9;StatusHealthy   HealthStatus = iota // 健康&#10;&#9;StatusUnhealthy                     // 不健康&#10;&#9;StatusUnknown                       // 未知&#10;)&#10;&#10;// NodeMetrics 节点指标&#10;type NodeMetrics struct {&#10;&#9;TotalRequests   int64         // 总请求数&#10;&#9;FailedRequests  int64         // 失败请求数&#10;&#9;SuccessRequests int64         // 成功请求数&#10;&#9;AvgLatency      time.Duration // 平均延迟&#10;&#9;LastCheckTime   time.Time     // 最后检查时间&#10;&#9;Status          HealthStatus  // 健康状态&#10;}&#10;&#10;// HealthChecker 健康检查器接口&#10;type HealthChecker interface {&#10;&#9;Check(addr string) error&#10;&#9;GetMetrics(addr string) *NodeMetrics&#10;&#9;Start()&#10;&#9;Stop()&#10;}&#10;&#10;// TCPHealthChecker TCP健康检查器&#10;type TCPHealthChecker struct {&#10;&#9;timeout       time.Duration&#10;&#9;interval      time.Duration&#10;&#9;maxErrorCount int&#10;&#9;metrics       map[string]*NodeMetrics&#10;&#9;errorCount    map[string]int&#10;&#9;mu            sync.RWMutex&#10;&#9;ctx           context.Context&#10;&#9;cancel        context.CancelFunc&#10;&#9;addresses     []string&#10;}&#10;&#10;// NewTCPHealthChecker 创建TCP健康检查器&#10;func NewTCPHealthChecker(timeout, interval time.Duration, maxErrorCount int) *TCPHealthChecker {&#10;&#9;ctx, cancel := context.WithCancel(context.Background())&#10;&#9;return &amp;TCPHealthChecker{&#10;&#9;&#9;timeout:       timeout,&#10;&#9;&#9;interval:      interval,&#10;&#9;&#9;maxErrorCount: maxErrorCount,&#10;&#9;&#9;metrics:       make(map[string]*NodeMetrics),&#10;&#9;&#9;errorCount:    make(map[string]int),&#10;&#9;&#9;ctx:           ctx,&#10;&#9;&#9;cancel:        cancel,&#10;&#9;&#9;addresses:     []string{},&#10;&#9;}&#10;}&#10;&#10;// AddAddress 添加要检查的地址&#10;func (h *TCPHealthChecker) AddAddress(addr string) {&#10;&#9;h.mu.Lock()&#10;&#9;defer h.mu.Unlock()&#10;&#9;&#10;&#9;// 检查是否已存在&#10;&#9;for _, existing := range h.addresses {&#10;&#9;&#9;if existing == addr {&#10;&#9;&#9;&#9;return&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;&#10;&#9;h.addresses = append(h.addresses, addr)&#10;&#9;if h.metrics[addr] == nil {&#10;&#9;&#9;h.metrics[addr] = &amp;NodeMetrics{&#10;&#9;&#9;&#9;Status:        StatusUnknown,&#10;&#9;&#9;&#9;LastCheckTime: time.Now(),&#10;&#9;&#9;}&#10;&#9;}&#10;}&#10;&#10;// Check 执行健康检查&#10;func (h *TCPHealthChecker) Check(addr string) error {&#10;&#9;start := time.Now()&#10;&#9;conn, err := net.DialTimeout(&quot;tcp&quot;, addr, h.timeout)&#10;&#9;latency := time.Since(start)&#10;&#10;&#9;h.mu.Lock()&#10;&#9;defer h.mu.Unlock()&#10;&#10;&#9;if h.metrics[addr] == nil {&#10;&#9;&#9;h.metrics[addr] = &amp;NodeMetrics{}&#10;&#9;}&#10;&#10;&#9;h.metrics[addr].TotalRequests++&#10;&#9;h.metrics[addr].LastCheckTime = time.Now()&#10;&#10;&#9;if err != nil {&#10;&#9;&#9;h.metrics[addr].FailedRequests++&#10;&#9;&#9;h.errorCount[addr]++&#10;&#9;&#9;&#10;&#9;&#9;if h.errorCount[addr] &gt;= h.maxErrorCount {&#10;&#9;&#9;&#9;h.metrics[addr].Status = StatusUnhealthy&#10;&#9;&#9;}&#10;&#9;&#9;return err&#10;&#9;}&#10;&#10;&#9;conn.Close()&#10;&#9;h.metrics[addr].SuccessRequests++&#10;&#9;h.errorCount[addr] = 0&#10;&#9;h.metrics[addr].Status = StatusHealthy&#10;&#10;&#9;// 更新平均延迟（简单移动平均）&#10;&#9;if h.metrics[addr].AvgLatency == 0 {&#10;&#9;&#9;h.metrics[addr].AvgLatency = latency&#10;&#9;} else {&#10;&#9;&#9;h.metrics[addr].AvgLatency = (h.metrics[addr].AvgLatency + latency) / 2&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;&#10;// GetMetrics 获取节点指标&#10;func (h *TCPHealthChecker) GetMetrics(addr string) *NodeMetrics {&#10;&#9;h.mu.RLock()&#10;&#9;defer h.mu.RUnlock()&#10;&#9;&#10;&#9;if metrics, ok := h.metrics[addr]; ok {&#10;&#9;&#9;// 返回副本避免并发问题&#10;&#9;&#9;return &amp;NodeMetrics{&#10;&#9;&#9;&#9;TotalRequests:   metrics.TotalRequests,&#10;&#9;&#9;&#9;FailedRequests:  metrics.FailedRequests,&#10;&#9;&#9;&#9;SuccessRequests: metrics.SuccessRequests,&#10;&#9;&#9;&#9;AvgLatency:      metrics.AvgLatency,&#10;&#9;&#9;&#9;LastCheckTime:   metrics.LastCheckTime,&#10;&#9;&#9;&#9;Status:          metrics.Status,&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return nil&#10;}&#10;&#10;// Start 启动健康检查&#10;func (h *TCPHealthChecker) Start() {&#10;&#9;go func() {&#10;&#9;&#9;ticker := time.NewTicker(h.interval)&#10;&#9;&#9;defer ticker.Stop()&#10;&#10;&#9;&#9;for {&#10;&#9;&#9;&#9;select {&#10;&#9;&#9;&#9;case &lt;-h.ctx.Done():&#10;&#9;&#9;&#9;&#9;return&#10;&#9;&#9;&#9;case &lt;-ticker.C:&#10;&#9;&#9;&#9;&#9;h.checkAll()&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}&#10;&#9;}()&#10;}&#10;&#10;// checkAll 检查所有地址&#10;func (h *TCPHealthChecker) checkAll() {&#10;&#9;h.mu.RLock()&#10;&#9;addresses := make([]string, len(h.addresses))&#10;&#9;copy(addresses, h.addresses)&#10;&#9;h.mu.RUnlock()&#10;&#10;&#9;for _, addr := range addresses {&#10;&#9;&#9;go func(address string) {&#10;&#9;&#9;&#9;if err := h.Check(address); err != nil {&#10;&#9;&#9;&#9;&#9;fmt.Printf(&quot;Health check failed for %s: %v\n&quot;, address, err)&#10;&#9;&#9;&#9;}&#10;&#9;&#9;}(addr)&#10;&#9;}&#10;}&#10;&#10;// Stop 停止健康检查&#10;func (h *TCPHealthChecker) Stop() {&#10;&#9;h.cancel()&#10;}&#10;&#10;// GetHealthyNodes 获取健康节点列表&#10;func (h *TCPHealthChecker) GetHealthyNodes() []string {&#10;&#9;h.mu.RLock()&#10;&#9;defer h.mu.RUnlock()&#10;&#10;&#9;healthy := []string{}&#10;&#9;for addr, metrics := range h.metrics {&#10;&#9;&#9;if metrics.Status == StatusHealthy {&#10;&#9;&#9;&#9;healthy = append(healthy, addr)&#10;&#9;&#9;}&#10;&#9;}&#10;&#9;return healthy&#10;}&#10;&#10;// HTTPHealthChecker HTTP健康检查器&#10;type HTTPHealthChecker struct {&#10;&#9;*TCPHealthChecker&#10;&#9;client     *http.Client&#10;&#9;healthPath string&#10;&#9;expectCode int&#10;}&#10;&#10;// NewHTTPHealthChecker 创建HTTP健康检查器&#10;func NewHTTPHealthChecker(timeout, interval time.Duration, maxErrorCount int, healthPath string, expectCode int) *HTTPHealthChecker {&#10;&#9;tcpChecker := NewTCPHealthChecker(timeout, interval, maxErrorCount)&#10;&#9;return &amp;HTTPHealthChecker{&#10;&#9;&#9;TCPHealthChecker: tcpChecker,&#10;&#9;&#9;client: &amp;http.Client{&#10;&#9;&#9;&#9;Timeout: timeout,&#10;&#9;&#9;},&#10;&#9;&#9;healthPath: healthPath,&#10;&#9;&#9;expectCode: expectCode,&#10;&#9;}&#10;}&#10;&#10;// Check HTTP健康检查&#10;func (h *HTTPHealthChecker) Check(addr string) error {&#10;&#9;start := time.Now()&#10;&#9;url := fmt.Sprintf(&quot;http://%s%s&quot;, addr, h.healthPath)&#10;&#9;resp, err := h.client.Get(url)&#10;&#9;latency := time.Since(start)&#10;&#10;&#9;h.mu.Lock()&#10;&#9;defer h.mu.Unlock()&#10;&#10;&#9;if h.metrics[addr] == nil {&#10;&#9;&#9;h.metrics[addr] = &amp;NodeMetrics{}&#10;&#9;}&#10;&#10;&#9;h.metrics[addr].TotalRequests++&#10;&#9;h.metrics[addr].LastCheckTime = time.Now()&#10;&#10;&#9;if err != nil || (h.expectCode &gt; 0 &amp;&amp; resp.StatusCode != h.expectCode) {&#10;&#9;&#9;h.metrics[addr].FailedRequests++&#10;&#9;&#9;h.errorCount[addr]++&#10;&#10;&#9;&#9;if h.errorCount[addr] &gt;= h.maxErrorCount {&#10;&#9;&#9;&#9;h.metrics[addr].Status = StatusUnhealthy&#10;&#9;&#9;}&#10;&#10;&#9;&#9;if resp != nil {&#10;&#9;&#9;&#9;resp.Body.Close()&#10;&#9;&#9;}&#10;&#9;&#9;return fmt.Errorf(&quot;health check failed: %v, status: %d&quot;, err, resp.StatusCode)&#10;&#9;}&#10;&#10;&#9;resp.Body.Close()&#10;&#9;h.metrics[addr].SuccessRequests++&#10;&#9;h.errorCount[addr] = 0&#10;&#9;h.metrics[addr].Status = StatusHealthy&#10;&#10;&#9;// 更新平均延迟&#10;&#9;if h.metrics[addr].AvgLatency == 0 {&#10;&#9;&#9;h.metrics[addr].AvgLatency = latency&#10;&#9;} else {&#10;&#9;&#9;h.metrics[addr].AvgLatency = (h.metrics[addr].AvgLatency + latency) / 2&#10;&#9;}&#10;&#10;&#9;return nil&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>